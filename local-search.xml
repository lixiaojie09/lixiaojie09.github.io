<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>用最简单的方法仿写Spring IOC</title>
    <link href="/2020/04/17/imitation-by-spring-ioc/"/>
    <url>/2020/04/17/imitation-by-spring-ioc/</url>
    
    <content type="html"><![CDATA[<h1 id="粗谈IOC和DI"><a href="#粗谈IOC和DI" class="headerlink" title="粗谈IOC和DI"></a>粗谈IOC和DI</h1><p>IOC（Inversion of Control，即控制反转）是把代码里需要用到的对象进行创建，放到容器中进行管理，并且令容器知道创建的对象与对象的依赖关系。一句话来说，就是要什么，我给你。</p><p>DI （Dependency Injection，即依赖注入）是指对象被动的接受依赖类，而不是对象主动去查找依赖类。一句话概括，就是我要的你给我。</p><h1 id="仿写实现"><a href="#仿写实现" class="headerlink" title="仿写实现"></a>仿写实现</h1><h2 id="项目结构以及实现思路"><a href="#项目结构以及实现思路" class="headerlink" title="项目结构以及实现思路"></a>项目结构以及实现思路</h2><p><img src="/img/2020/04/17/1.png" srcset="/img/loading.gif" alt="项目结构"></p><ol><li>@Component注解是将带该注解的类注册成Bean，并放到IOC容器中，@Autowired注解是依赖注入属性</li><li>BeanFactory中的initBeanFactory()方法是初始化IOC容器，该方法会依次执行initBeanDefinition()、dependencyInjection()</li><li>initBeanDefinition()是通过扫描指定包路径下的带有@Component的类注册到beanMap中</li><li>dependencyInjection()是通过已注册的bean依赖注入带@Autowired注解的属性实例。</li><li>初始化完成后，调用BeanFactory.getBean()拿到Bean</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="Component、-Autowired注解"><a href="#Component、-Autowired注解" class="headerlink" title="@Component、@Autowired注解"></a>@Component、@Autowired注解</h3><pre><code class="java">@Retention(RUNTIME)@Target({FIELD})public @interface Autowired {}</code></pre><pre><code class="java">@Retention(RUNTIME)@Target({TYPE})public @interface Component {    int priority() default Integer.MAX_VALUE - 1;}</code></pre><h3 id="BeanFactory实现"><a href="#BeanFactory实现" class="headerlink" title="BeanFactory实现"></a>BeanFactory实现</h3><pre><code class="java">@Slf4jpublic class BeanFactory {    private static Map&lt;Class&lt;?&gt;, List&lt;BeanDefinition&gt;&gt; beanMap = new ConcurrentHashMap&lt;&gt;();    /**     * 获得类型获取bean     */    public static &lt;T&gt; T getBean(Class&lt;T&gt; bean) {        List&lt;BeanDefinition&gt; beanDefinitions = beanMap.get(bean);        if (beanDefinitions != null &amp;&amp; !beanDefinitions.isEmpty()) {            return (T) beanDefinitions.get(0).getInstance();        }        return null;    }    public static void initBeanFactory(String packageName) throws Exception {        // 实例化Bean        initBeanDefinition(packageName);        // 依赖注入        dependencyInjection();        log.debug(&quot;-&gt; BeanFactory初始化成功&quot;);    }    /**     * 实例化Bean     *     * @param packageName     * @throws Exception     */    private static void initBeanDefinition(String packageName) throws Exception {        log.debug(&quot;-&gt; Bean 实例化并注册 [开始]&quot;);        // 获取指定包名packageName下的所有带@Component注解的类        List&lt;Class&lt;?&gt;&gt; list = BeanUtils.findAllByAnnotation(packageName, Component.class);        if (list != null &amp;&amp; !list.isEmpty()) {            for (Class&lt;?&gt; child : list) {                log.debug(&quot;-&gt; register bean : {}&quot;, child.getName());                // 将带@Component注解的类封装成BeanDefinition                BeanDefinition beanDefinition = new BeanDefinition();                String name = child.getName();                beanDefinition.setBeanName(firstCharToLowerCase(name));                beanDefinition.setSuperClassType(child.getSuperclass());                Class&lt;?&gt;[] interfaces = child.getInterfaces();                beanDefinition.setInterfaceTypes(Arrays.asList(interfaces));                beanDefinition.setClassType(child);                beanDefinition.setInstance(child.newInstance());                Component component = child.getDeclaredAnnotation(Component.class);                beanDefinition.setPriority(component.priority());                // 加载到beanMap                addToMapAndSort(beanDefinition);            }        }        log.debug(&quot;-&gt; Bean 实例化并注册 [完成]&quot;);    }    private static void addToMapAndSort(final BeanDefinition beanDefinition) {        List&lt;Class&lt;?&gt;&gt; interfaceTypes = beanDefinition.getInterfaceTypes();        List&lt;Class&lt;?&gt;&gt; beanTypes = new ArrayList&lt;&gt;();        // 若实例有继承接口的，beanMap以接口类型为key，否则以当前实例类做keyk        if (interfaceTypes.isEmpty()) {            // 实现类            beanTypes.add(beanDefinition.getClassType());        } else {            // 所有接口            beanTypes.addAll(interfaceTypes);        }        // 每个接口的类型都包含该实现类        beanTypes.forEach(beanType -&gt; registerOne(beanType, beanDefinition));    }    private static void registerOne(Class&lt;?&gt; beanType, BeanDefinition beanDefinition) {        List&lt;BeanDefinition&gt; definitions = beanMap.computeIfAbsent(beanType, b -&gt; new CopyOnWriteArrayList&lt;&gt;());        definitions.add(beanDefinition);        definitions.sort(Comparator.comparingInt(BeanDefinition::getPriority));    }    /**     * 依赖注入     */    private static void dependencyInjection() throws IllegalAccessException {        log.debug(&quot;-&gt; 依赖注入 [开始]&quot;);        if (beanMap.isEmpty()) {            return;        }        // 通过已注册进beanMap中的Bean依赖注入带@Autowired注解的属性        Iterator&lt;Map.Entry&lt;Class&lt;?&gt;, List&lt;BeanDefinition&gt;&gt;&gt; iterator = beanMap.entrySet().iterator();        while (iterator.hasNext()) {            Map.Entry&lt;Class&lt;?&gt;, List&lt;BeanDefinition&gt;&gt; next = iterator.next();            List&lt;BeanDefinition&gt; definitions = next.getValue();            if (definitions != null &amp;&amp; !definitions.isEmpty()) {                for (BeanDefinition definition : definitions) {                    Object instance = definition.getInstance();                    if (instance != null) {                        // 反射设置值                        Field[] fields = instance.getClass().getDeclaredFields();                        for (Field field : fields) {                            Autowired autowired = field.getDeclaredAnnotation(Autowired.class);                            if (autowired != null) {                                // 开启属性的反射访问权限                                if (!field.isAccessible()) {                                    field.setAccessible(true);                                }                                Class&lt;?&gt; fieldType = field.getType();                                // 获取类型的实例                                Object bean = getBean(fieldType);                                if (bean == null) {                                    throw new BeanException(MessageFormat.format(&quot;{0} 注入属性失败, 容器中不存在 {1}&quot;,                                            instance.getClass().getName(), fieldType.getName()));                                }                                // 设置值                                field.set(instance, bean);                            }                        }                    }                }            }        }        log.debug(&quot;-&gt; 依赖注入 [完成]&quot;);    }    private static String firstCharToLowerCase(String str) {        return str.substring(0, 1).toLowerCase() + str.substring(1);    }}</code></pre><h3 id="包扫描工具类-BeanUtils"><a href="#包扫描工具类-BeanUtils" class="headerlink" title="包扫描工具类 BeanUtils"></a>包扫描工具类 BeanUtils</h3><p>该工具类是通过当前线程的ContextClassLoader的路径拼接上指定的包路径递归获取出所有的.class文件，然后过滤带有@Component注解的.class文件进行返回。</p><pre><code class="java">public class BeanUtils {    private static final String CLASS_SUFFIX = &quot;.class&quot;;    public static List&lt;Class&lt;?&gt;&gt; findAllByAnnotation(String packageName, Class&lt;? extends Annotation&gt; annotation) throws Exception {        Objects.requireNonNull(annotation, &quot;扫描注解异常!&quot;);        if (StringUtils.isEmpty(packageName)) {            throw new IllegalArgumentException(&quot;扫描路径异常!&quot;);        }        List&lt;Class&lt;?&gt;&gt; classes = new ArrayList&lt;&gt;();        String path = packageName.replace(&quot;.&quot;, &quot;/&quot;);        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();        URL url = contextClassLoader.getResource(path);        if (url != null) {            List&lt;Class&lt;?&gt;&gt; targets = getClasses(new File(URLDecoder.decode(url.getFile(), &quot;UTF-8&quot;)), packageName);            for (Class&lt;?&gt; target : targets) {                if (target.getDeclaredAnnotation(annotation) != null) {                    classes.add(target);                }            }        }        return classes;    }    private static List&lt;Class&lt;?&gt;&gt; getClasses(File file, String packageName) throws Exception {        Objects.requireNonNull(file, &quot;&quot;);        File[] children = file.listFiles();        List&lt;Class&lt;?&gt;&gt; classes = new ArrayList&lt;&gt;();        for (File child : children) {            String name = child.getName();            // 文件夹递归获取            if (child.isDirectory()) {                classes.addAll(getClasses(child, packageName + &quot;.&quot; + name));            }            // 判断是否为class文件            if (name.endsWith(CLASS_SUFFIX)) {                String className = packageName + &quot;.&quot; + name.substring(0, name.length() - CLASS_SUFFIX.length());                classes.add(Class.forName(className));            }        }        return classes;    }}</code></pre><p>到此核心的代码已经介绍完了。现在主要是验证下这个简单的IOC容器是否能正确的运行。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="UserService、UserServiceImpl"><a href="#UserService、UserServiceImpl" class="headerlink" title="UserService、UserServiceImpl"></a>UserService、UserServiceImpl</h4><pre><code class="java">public interface UserService {    String findByName(int id);    JSONObject findUserRoles(int id);}</code></pre><pre><code class="java">@Componentpublic class UserServiceImpl implements UserService {    @Autowired    private RoleService roleService;    @Override    public String findByName(int id) {        return &quot;Hello world! &quot; + id;    }    @Override    public JSONObject findUserRoles(int id) {        JSONObject object = new JSONObject();        object.put(&quot;name&quot;, findByName(id));        object.put(&quot;roles&quot;, roleService.findByUserId(id));        return object;    }}</code></pre><h4 id="RoleService、RoleServiceImpl"><a href="#RoleService、RoleServiceImpl" class="headerlink" title="RoleService、RoleServiceImpl"></a>RoleService、RoleServiceImpl</h4><pre><code class="java">public interface RoleService {    List&lt;String&gt; findByUserId(int id);}</code></pre><pre><code class="java">@Componentpublic class RoleServiceImpl implements RoleService {    @Override    public List&lt;String&gt; findByUserId(int id) {        return Stream.of(&quot;超级管理员&quot;,&quot;租户管理员&quot;).collect(Collectors.toList());    }}</code></pre><h4 id="Application测试类"><a href="#Application测试类" class="headerlink" title="Application测试类"></a>Application测试类</h4><p>UserService中使用@Autowired注入了RoleSerivce的。所以校验的时候会先执行UserService的findByName，再执行findUserRoles方法。</p><p>代码实现如下</p><pre><code class="java">@Slf4jpublic class Application {    public static void main(String[] args) throws Exception {        // 初始化bean        BeanFactory.initBeanFactory(Application.class.getPackage().getName());        // 获得bean并执行方法        UserService bean = BeanFactory.getBean(UserService.class);        // 预测返回 &quot;Hello world! 1&quot;        log.info(&quot;-&gt; 执行bean中的findByName()方法 : {}&quot;, bean.findByName(1));        // 预测返回 name = 1,roles = [&quot;超级管理员&quot;,&quot;租户管理员&quot;]        log.info(&quot;-&gt; 执行bean中的findUserRoles()方法 : {}&quot;, bean.findUserRoles(1));    }}</code></pre><p>代码执行如下</p><p><img src="/img/2020/04/17/2.png" srcset="/img/loading.gif" alt="运行结果"></p><p>到此，预期的结果和运行的结果是一致的。</p><hr><p>这种实现的逻辑虽然没有Spring的Ioc这么强大，但起码也实现了最简单的Ioc逻辑。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录使用Hexo搭建博客</title>
    <link href="/2020/04/12/used-by-hexo-github-to-build-blog/"/>
    <url>/2020/04/12/used-by-hexo-github-to-build-blog/</url>
    
    <content type="html"><![CDATA[<p>本文章记录使用Hexo搭建个人博客以及部分使用技巧</p><a id="more"></a><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><h3 id="安装Hexo以及启动服务"><a href="#安装Hexo以及启动服务" class="headerlink" title="安装Hexo以及启动服务"></a>安装Hexo以及启动服务</h3><ul><li>安装</li></ul><pre><code>npm install -g hexo</code></pre><ul><li>初始化hexo目录</li></ul><pre><code>cd ..进入目录hexo init</code></pre><p>等待拉去github上的hexo项目，拉去完成后的项目结构如下<br> <img src="/img/2020/04/12/1.png" srcset="/img/loading.gif" alt="image"></p><ul><li>生成public文件夹</li></ul><pre><code>hexo g #在public文件夹生成相关html文件</code></pre><p>执行 hexo g命令后，会创建一个public的文件夹，里面的html将来都是要提交到github去的。<br><img src="/img/2020/04/12/2.png" srcset="/img/loading.gif" alt="image"></p><ul><li>启动服务</li></ul><pre><code>hexo s #启动hexo服务</code></pre><p>启动完成后，在浏览器中输入<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a>可以访问到启动的hexo服务</p><p> <img src="/img/2020/04/12/3.png" srcset="/img/loading.gif" alt="image"></p><h3 id="Hexo更换皮肤"><a href="#Hexo更换皮肤" class="headerlink" title="Hexo更换皮肤"></a>Hexo更换皮肤</h3><p>首先去<a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo皮肤库</a>物色一个心仪的皮肤，个人觉得ht<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener">hexo-theme-fluid</a>这个皮肤炫酷，就以这个为例更换皮肤。</p><ul><li>先进入本地hexo文件夹，执行以下命令拉皮肤源码</li></ul><pre><code>git clone https://github.com/fluid-dev/hexo-theme-fluid.git themes/fluid</code></pre><p>拉取源码完成后，在themes目录下（该目录时所有皮肤的存放目录）</p><ul><li>换皮肤</li></ul><p>修改根目录下的_config.yml文件</p><pre><code>theme: fluid  # 指定主题language: zh-CN  # 指定语言，可不改</code></pre><ul><li>重新启动</li></ul><pre><code>hexo cleanhexo ghexo s</code></pre><ul><li>重启后就焕然一新了<br><img src="/img/2020/04/12/4.png" srcset="/img/loading.gif" alt="image"></li></ul><h3 id="常用hexo命令"><a href="#常用hexo命令" class="headerlink" title="常用hexo命令"></a>常用hexo命令</h3><pre><code>hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）hexo deploy #部署到GitHubhexo help  # 查看帮助hexo version  #查看Hexo的版本## 缩写hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy## 组合命令hexo s -g #生成并本地预览hexo d -g #生成并上传</code></pre><h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h3><p>全局配置</p><h2 id="创作新文章"><a href="#创作新文章" class="headerlink" title="创作新文章"></a>创作新文章</h2><p>进入到我们的hexo项目根目录，执行以下命令</p><pre><code>hexo new &#39;new bloger page&#39;</code></pre><p>hexo会帮我们在_posts下生成相关md文件，我们只需要打开这个文件就可以开始写博客了。</p><p>一般完整格式如下</p><pre><code>---title: first page #文章页面上的显示名称，一般是中文date: 2020-04-12 01:04:14 #文章生成时间，一般不改，当然也可以任意修改tags: #文章标签，可空，多标签请用格式，注意:后面有个空格categories: 默认分类 #分类description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面---以下是正文</code></pre><p>如何让博文列表不显示全部内容<br>默认情况下，生成的博文目录会显示全部的文章内容，位置加上</p><pre><code>&lt;!--more--&gt;</code></pre><h2 id="当前主题的官网以及使用文档"><a href="#当前主题的官网以及使用文档" class="headerlink" title="当前主题的官网以及使用文档"></a>当前主题的官网以及使用文档</h2><p><a href="https://hexo.fluid-dev.com/docs" target="_blank" rel="noopener">官网</a></p><p><a href="https://hexo.fluid-dev.com/docs/guide/" target="_blank" rel="noopener">使用文档</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nacos-server-1.1.4适配MySQL8</title>
    <link href="/2020/03/11/nacos-server-1-1-4-support-mysql8/"/>
    <url>/2020/03/11/nacos-server-1-1-4-support-mysql8/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在部署Nacos注册中心的时候，连接的MySQL是版本是8，配置了DB相关的信息以及执行了数据库脚本并且在服务器上启动服务，当一切都很顺利的时候，意外从此发生了。哈哈哈哈，本来想修改默认的密码，结果提交的时候并没什么反应，重试了好几次也没啥效果，凭着感觉按下F12，再提交一次，这时发现接口报500。<br><img src="/img/2020/03/11/1.png" srcset="/img/loading.gif" alt=""><br>既然是接口异常，那就上服务器查看一下日志<br><img src="/img/2020/03/11/2.png" srcset="/img/loading.gif" alt=""><br>经过一顿操作，发现时Nacos的驱动包与MySQL版本不兼容。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>我的解决方法是，download源码，修改驱动版本，然后用maven重新编译这个过程去获得一个新的而且支持MySQL8的Nacos-server-1.1.4.jar。</p><p><strong>1.下载源码</strong></p><p>通过全球最大的交友网站<a href="https://github.com/alibaba/nacos/tree/1.1.4" target="_blank" rel="noopener">Github</a>去拉去代码到本地。然后导入到IDEA，这时，你需要经历一漫长的maven导包过程。</p><p>2000 years later</p><p><strong>2.修改驱动版本</strong></p><p>将pom.xml文件的mysql驱动包作如下修改</p><pre><code class="xml">&lt;!-- 原有的版本 --&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;5.1.34&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 修改后的版本 --&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;8.0.17&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>修改完pom.xml文件，还重新导入<strong>naming</strong>模块下的<strong>com.alibaba.nacos.naming.healthcheck.MysqlHealthCheckProcessor</strong>的MysqlDataSource</p><pre><code class="java">// 原来的 import com.mysql.jdbc.jdbc2.optional.MysqlDataSource;// 改成import com.mysql.cj.jdbc.MysqlDataSource;</code></pre><p><strong>3.重新编译</strong></p><p>此时，只需要重新编译一下nacos的源码即可</p><pre><code>mvn -Prelease-nacos -DskipTests clean install -U</code></pre><p>2000 years later</p><p>编译完成后，在<strong>distribution</strong>模块中的target目录下即可找到nacos-server.jar。</p><p><strong>4.重新部署</strong></p><p>部署的方法很简单，在服务器原来解压后的目录下并且进入target子目录，重新上传并替换掉nacos-server.jar。此时离成功就只差一步了，那就是修改配置文件</p><pre><code>spring.datasource.platform=mysqldb.num=1db.url.0=jdbc:mysql://ip:port/nacos_qa?characterEncoding=utf8&amp;connectTimeout=1000&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=Asia/Shanghaidb.user=db.password=</code></pre><p>最后进入bin目录，执行命令启动就可以了</p><pre><code class="shell">sh startup.sh -m standalone</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
